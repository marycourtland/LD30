// Generated by CoffeeScript 1.7.1
var __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

bz.Slider = (function(_super) {
  __extends(Slider, _super);

  function Slider(game, params) {
    Slider.__super__.constructor.apply(this, arguments);
    params || (params = {});
    this.pos = params.pos || xy(100, 100);
    this.arm = rth(params.length || 100, (params.orientation === 'v' ? -Math.PI / 2 : 0));
    this.label = params.label || "";
    this.graphics.width = 10;
    this.graphics.color = 'silver';
    this.graphics.handle_width = 30;
    this.graphics.handle_length = 20;
    this.graphics.handle_color = 'black';
    this.graphics.indicator_pos = add(this.pos, params.indicator_pos || (this.arm.th === 0 ? xy(-50, 0) : xy(0, 50)));
    this.graphics.label_pos = add(this.pos, params.label_pos || (this.arm.th === 0 ? xy(-50, 0) : xy(0, 50)));
    this.scale = {
      min: params.min || 0,
      max: params.max || 1000
    };
    this.value = params.value || 0;
    this.draw_params = {};
    this.recalculate = function() {
      var fraction, handle_pos;
      fraction = (this.value - this.scale.min) / (this.scale.max - this.scale.min);
      handle_pos = add(this.pos, scale(this.arm, fraction));
      this.draw_params.endpoint = this.endpoint();
      this.draw_params.handle1 = add(handle_pos, rth(this.graphics.handle_length / 2, this.arm.th));
      return this.draw_params.handle2 = add(handle_pos, rth(-this.graphics.handle_length / 2, this.arm.th));
    };
    this.on('draw', function() {
      draw.line(this.ctx, this.pos, this.draw_params.endpoint, {
        linewidth: this.graphics.width,
        stroke: this.graphics.color
      });
      draw.line(this.ctx, this.draw_params.handle1, this.draw_params.handle2, {
        linewidth: this.graphics.handle_width,
        stroke: this.graphics.handle_color
      });
      return draw.text(this.ctx, this.value.toString(), this.graphics.indicator_pos, 'centered');
    });
    this.on('drag', function(p) {
      this.value = this.getSettingFromPos(p);
      return this.recalculate();
    });
    this.on('click', function(p) {
      this.value = this.getSettingFromPos(p);
      return this.recalculate();
    });
    this.endpoint = function() {
      return add(this.pos, this.arm);
    };
    this.getSettingFromPos = function(p) {
      var d, proj, s;
      proj = this.project(p);
      d = this.arm.th === 0 ? proj.x - this.pos.x : this.pos.y - proj.y;
      s = this.scale.min + d / this.arm.r * (this.scale.max - this.scale.min);
      return Math.max(Math.min(s, this.scale.max), this.scale.min);
    };
    this.project = function(p) {
      return xy((this.arm.th === 0 ? p.x : this.pos.x), (this.arm.th === 0 ? this.pos.y : p.y));
    };
    this.contains = function(p) {
      return isOnLineSegment(p, this.pos, this.endpoint(), Math.max(this.graphics.width / 2, this.graphics.handle_width / 2));
    };
    this.recalculate();
  }

  return Slider;

})(GameObject);
